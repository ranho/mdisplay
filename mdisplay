#!/usr/bin/python2
# -*- coding: utf-8 -*-
# 
# Author: rupi <rupi@devlol.org>
# This program is Free Software and licensed under the terms of GPLv3 or later
# http://www.gnu.org/copyleft/gpl.html

import warnings
import signal
import sys
import os
import math
import time
import re
import socket
import fcntl
import struct
import ConfigParser

import mpd
import Adafruit_CharLCD as LCD

## handler objects
mpc = mpd.MPDClient()

## define extra chars
def lcd_init():
	lcd.set_color(cfg['red'],cfg['green'],cfg['blue'])
	# play 
	lcd.create_char(1, [8, 12, 10, 9, 10, 12, 8, 0])
	# note
	lcd.create_char(2, [2, 3, 2, 2, 14, 30, 12, 0])
	# radio
	lcd.create_char(3, [0b00010,
						0b00100,
						0b01000,
						0b10000,
						0b11111,
						0b10001,
						0b11111,
						0b00000])
	# hourglas
	lcd.create_char(4, [31, 17, 10, 4, 10, 17, 31, 0])
	# stop
	lcd.create_char(5, [31, 17, 21, 21, 21, 21, 17, 31])
	# pause
	lcd.create_char(6, [0b11011,
						0b11011,
						0b11011,
						0b11011,
						0b11011,
						0b11011,
						0b11011,
						0b00000])

## cleanup
def lcd_off():
	lcd.clear()
	lcd.enable_display(False)
	lcd.set_backlight(0)

def lcd_on():
	lcd.set_color(cfg['red'],cfg['green'],cfg['blue'])
	lcd.enable_display(True)
	
def sig_handler(sig, frame):
	mpc.close()
	lcd_off()

	if sig == signal.SIGTERM:
		print "shutdown received"
		sys.exit(0)
	else:
		print "interrupted"
		sys.exit(1)

signal.signal(signal.SIGINT, sig_handler)
signal.signal(signal.SIGTERM, sig_handler)

def display_volume():
	"""
	Display current mpd volume in second row (don't clear display).
	"""
	status = mpc.status()
	lcd.set_cursor(0,1)
	lcd.message("Volume: %3d     " % int(status['volume']))

def mpc_directory(name):
	"""
	Set playlist to given directory and start playing. This method blocks
	if a database update is currently running.
	@returns boolean state of success
	"""
	try:
		try:
			mpc.status()['updating_db']
			lcd.clear()
			lcd.message('\x04 update DB..')
			mpc.idle('update')
		except KeyError:
			pass

		mpc.clear()
		mpc.add(name)
		mpc.play()

	except (mpd.CommandError, mpd.ConnectionError):
		return False
	return True

def mpc_list(name):
	"""
	Set playlist to given playlist and start playing.
	@returns boolean state of success
	"""
	try:
		mpc.clear()
		mpc.load(name)
		mpc.play()
	except (mpd.CommandError, mpd.ConnectionError):
		return False

	return True

def mpd_stop(ignored):
	"""
	We need a stop function that returns true for main menu.
	"""
	try:
		mpc.stop()
		lcd_off()
		return True
	except (mpd.CommandError, mpd.ConnectionError):
		return False

def mpc_gettitle(song):
	"""
	Get current song from mpc and return a titlestring.
	"""
	titlestr = u""
	try:
		titlestr = song['artist'].decode('utf-8') + u" / "
	except KeyError:
		pass
	try:
		titlestr = titlestr  + song['title'].decode('utf-8')
	except KeyError:
		try:
			titlestr = titlestr + song['name'].decode('utf-8')
		except KeyError:
			try:
				titlestr = song['file']
			except KeyError: ## this means clear playlist, no song..
				pass

	# no newlines
	titlestr = re.sub('\n',' ',titlestr)
	if len(titlestr) < 16: 
		titlestr = titlestr.ljust(16,' ')
	return titlestr.encode('ascii','replace')

def main_menu():
	"""
	Top level of menu.
	Menu items are generated by sub functions - these functions are expected
	to return lists of options. 
	An option is a dict with 3 keys:
	 display: the text to display (will be prefixed by x/n (2 digits)
	 cmd: the command to execute (global function)
	 arg: the argument to this function
	"""

	def usb_opts():
		""" Generate usb storage options for menu.
		@returns list
		"""
		options = []

		# test if we find an USB drive mounted
		usb = []
		try:
			usb = os.listdir('/mnt/MPD/USB')
		except os.OSError:
			pass

		for i in usb:
			n = i.decode('utf-8')
			options.append({
				'display': 'USB media\n' + n.encode('ascii','replace'),
				'cmd': mpc_directory,
				'arg': 'USB/'+i})
			
		return options

	def playlists_opts():
		""" Generate playlist options for menu.
		"""
		options = []

		playlists = []
		for i in mpc.listplaylists():
			playlists.append(i['playlist'])
		playlists.sort()

		for i in playlists:
			n = i.decode('utf-8')
			options.append({
				'display': 'Playlist \x02\n'+n.encode('ascii', 'replace'),
				'cmd': mpc_list,
				'arg': i})

		return options

	def webradio_opts():
		""" Generate webradio bookmark options for menu.
		"""
		options = []

		# webradio name match
		webre = re.compile('^Webradio\/(?P<name>.*)\.pls$')
		playlists = []
		try:
			for i in mpc.lsinfo('Webradio'):
				playlists.append(i['playlist'])
			playlists.sort()
		except: # should not happen.. worst case the list is empy, no harm
			pass
		
		for i in playlists:
			m = webre.match(i)
			if m:
				n = m.group('name').decode('utf-8')
			else:
				n = i.decode('utf-8')

			options.append({
				'display': 'Webradio \x03\n' + n.encode('ascii','replace'),
				'cmd': mpc_list,
				'arg': i})
		
		return options

	def ip_opts():
		""" Generate show ip option for menu.
		"""
		ip = socket.gethostbyname(socket.gethostname())

		# code found here:
		# http://stackoverflow.com/questions/11735821/python-get-localhost-ip
		if ip.startswith("127."):
			interfaces = [
				"eth0",
				"eth1",
				"wlan0",
				"wifi0"
				]
			for ifname in interfaces:
				try:
					s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
					ip = socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, 
						struct.pack('256s', ifname[:15]))[20:24])
					break
				except IOError:
					pass

		return [{'display': 'IP address\n' + ip,
			'cmd': lambda x: x,
			'arg': True}]

	def stop_opts():
		""" Generate stop option for menu.
		"""
		return [{'display': 'Stop     \x05\nTurn display off',
			'cmd': mpd_stop,
			'arg': True}]

	## menu start
	lcd.clear()
	mainopts = []

	for i in cfg['menu']:
		try:
			mainopts.extend(locals()[i+'_opts']())
		except KeyError:
			print "unknown menu option %s" % i


	## menu loop
	i = 0 # menu option index
	j = 1 # previous menu option index
	nopts = len(mainopts)
	ts = time.time() # timestamp for menu timout
	timeout = cfg['timeout'] # menu timeout

	while True:
		
		if time.time() > ts + timeout:
			if stopped:
				lcd_off()
			else:
				lcd.clear()
			return

		mpc.ping() # avoid timeout while we're in menu
		if i != j:
			j = i
			lcd.clear()
			lcd.message("%02d/%02d %s" % (i+1, nopts, mainopts[i]['display']))

		if lcd.is_pressed(LCD.SELECT):
			ts = time.time()
			if mainopts[i]['cmd'](mainopts[i]['arg']):
				lcd.clear()
				return
			else:
				lcd.clear()
				## display that there was an error for a short time
				lcd.message("Error..")
				time.sleep(1.0)	
				return

		elif lcd.is_pressed(LCD.LEFT):
			ts = time.time()
			i = i - 1	
			if i < 0: i = nopts -1

		elif lcd.is_pressed(LCD.RIGHT):
			ts = time.time()
			i = i + 1
			if i == nopts: i = 0

		# cancel menu
		elif lcd.is_pressed(LCD.UP) or lcd.is_pressed(LCD.DOWN):
			if stopped:
				lcd_off()
			else:
				lcd.clear()
			return
			
		time.sleep(0.25)	

## parse config
defaults = { 'features': "usb playlists webradio ip stop",
        'timeout': 15,
        'red': 1.0,
        'green': 1.0,
        'blue': 1.0 }
conf = ConfigParser.SafeConfigParser(defaults)
conf.read('/etc/mpdisplay.cfg')
cfg = {}

# color
for i in [ 'red', 'green', 'blue' ]:
    try:
        cfg[i] = conf.getfloat('color',i)
    except ValueError:
        print "Config: invalid value for %s: %s" % (i, conf.get('color',i))
        cfg[i] = defaults[i]

# timeout
try:
    cfg['timeout'] = conf.getint('menu','timeout')
except ValueError:
	print "Config: invalid value for timout: %s" % conf.get('menu','timeout')
	cfg['timeout'] = defaults['timeout']

# menu items
valids = defaults['features'].split()
cfg['menu'] = []
for i in conf.get('menu','features').split():
    if i in valids:
        cfg['menu'].append(i)
    else:
        print "Config: invalid menu item %s (ignored)" % i

if len(cfg['menu']) == 0:
    print "Config: no usable menu, using defaults"
    cfg['menu'] = valids

## setup handler
try:
	mpc.connect("localhost", 6600)
except Exception, e:
	lcd_off()
	print "MPD connection error: %s" % str(e)
	sys.exit(2)

try:
	lcd = LCD.Adafruit_CharLCDPlate()
	lcd_init()
	lcd_on()
## Exit gracefully if no display is found to prevent systemd from trying to
#  restart indefinitly.
except IOError:
	print "IOError: no diplay found (exiting program)"
	sys.exit(0)

print ('MPDisplay ready / press CTRL-C to quit')

## various state varibables
song = False 
stopped = False
menu = False
playpressed = False

## main loop
while True:
	
	stime = 0.25 # default sleep 1/4 sec (less wait for button pressed)
	try:
		status = mpc.status()
	except (mpd.ConnectionError, socket.error):
		try:
			mpc = mpd.MPDClient()
			mpc.connect('localhost', 6600)
		except:
			print "Reconnect to MPD failed (giving up)"
			sys.exit(1)

	if status['state'] == 'play':
		# re-enable display if we where stopped
		if stopped:
			stopped = False
			lcd_on()

		if lcd.is_pressed(LCD.UP):
			mpc.volume(2)
			display_volume()

		elif lcd.is_pressed(LCD.DOWN):
			mpc.volume(-2)
			display_volume()

		elif lcd.is_pressed(LCD.LEFT):
			mpc.previous()

		elif lcd.is_pressed(LCD.RIGHT):
			mpc.next()

		elif lcd.is_pressed(LCD.SELECT):
			if not playpressed:
				mpc.pause() # toggles
				playpressed = True

		else:
			playpressed = False
			# fetch song if necessary
			if not song or status['songid'] != song['id']:
				song = mpc.currentsong()
				titlestr = mpc_gettitle(song)
				length = len(titlestr)
				index = 0

			if index + 16 > length:
				index = 0

			dtitle = titlestr[index:index + 16]

			## construct state part of display
			#  time is current:duration
			cur, dur = status['time'].split(":")
			cur = int(cur)
			dur = int(dur)
			cmin, csec = divmod(cur,60) # 1st part is play time
			dmin, dsec = divmod(dur,60)
			tstr = "%3d:%02d" % (cmin,csec)
			if dur == 0:
				tstr = tstr +"/--:--"
			else:
				tstr = tstr +"/%02d:%02d" % ( dmin,dsec )
			dstatus = "\x01   " + tstr

			lcd.set_cursor(0,0)
			lcd.message(dtitle + '\n'+ dstatus)

			index = index + 1

			stime = 0.75 # longer default sleep for normal display

	elif status['state'] == 'pause':
		lcd.set_cursor(0,1)
		lcd.message("\x06")

		if lcd.is_pressed(LCD.SELECT):
			if not playpressed:
				mpc.pause() # toggles
				playpressed = True

		elif lcd.is_pressed(LCD.UP) or lcd.is_pressed(LCD.DOWN) or lcd.is_pressed(LCD.LEFT) or lcd.is_pressed(LCD.RIGHT):
			playpressed = False
			main_menu()

			# display title again after menu
			# don't display paused.. we may started playing a playlist
			lcd.set_cursor(0,0)
			lcd.message(mpc_gettitle(mpc.currentsong()))

		else:
			playpressed = False

	elif status['state'] == 'stop':
		if lcd.is_pressed(LCD.UP) or lcd.is_pressed(LCD.DOWN) or lcd.is_pressed(LCD.LEFT) or lcd.is_pressed(LCD.RIGHT):
			playpressed = False
			lcd_on()
			main_menu()

		elif lcd.is_pressed(LCD.SELECT):
			playpressed = True
			if len(mpc.playlist()):
				mpc.play()
			else:
				lcd_on()
				main_menu()

		else:
			playpressed = False
			if not stopped:
				lcd_off()
				stopped = True
		
	## sucks.. but we're not responsive till next cycle
	time.sleep(stime)	
